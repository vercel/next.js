(()=>{"use strict";if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var t={};(()=>{var e=t;Object.defineProperty(e,"__esModule",{value:true});e.LRUCache=void 0;const i=typeof performance==="object"&&performance&&typeof performance.now==="function"?performance:Date;const s=new Set;const n=typeof process==="object"&&!!process?process:{};const emitWarning=(t,e,i,s)=>{typeof n.emitWarning==="function"?n.emitWarning(t,e,i,s):console.error(`[${i}] ${e}: ${t}`)};let h=globalThis.AbortController;let a=globalThis.AbortSignal;if(typeof h==="undefined"){a=class AbortSignal{onabort;_onabort=[];reason;aborted=false;addEventListener(t,e){this._onabort.push(e)}};h=class AbortController{constructor(){warnACPolyfill()}signal=new a;abort(t){if(this.signal.aborted)return;this.signal.reason=t;this.signal.aborted=true;for(const e of this.signal._onabort){e(t)}this.signal.onabort?.(t)}};let t=n.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1";const warnACPolyfill=()=>{if(!t)return;t=false;emitWarning("AbortController is not defined. If using lru-cache in "+"node 14, load an AbortController polyfill from the "+"`node-abort-controller` package. A minimal polyfill is "+"provided for use by LRUCache.fetch(), but it should not be "+"relied upon in other contexts (eg, passing it to other APIs that "+"use AbortController/AbortSignal might have undesirable effects). "+"You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",warnACPolyfill)}}const shouldWarn=t=>!s.has(t);const o=Symbol("type");const isPosInt=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t);const getUintArray=t=>!isPosInt(t)?null:t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?ZeroArray:null;class ZeroArray extends Array{constructor(t){super(t);this.fill(0)}}class Stack{heap;length;static#t=false;static create(t){const e=getUintArray(t);if(!e)return[];Stack.#t=true;const i=new Stack(t,e);Stack.#t=false;return i}constructor(t,e){if(!Stack.#t){throw new TypeError("instantiate Stack using Stack.create(n)")}this.heap=new e(t);this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class LRUCache{#e;#i;#s;#n;#h;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#a;#o;#r;#l;#c;#f;#d;#u;#p;#g;#S;#y;#m;#z;#w;#L;#_;static unsafeExposeInternals(t){return{starts:t.#m,ttls:t.#z,sizes:t.#y,keyMap:t.#r,keyList:t.#l,valList:t.#c,next:t.#f,prev:t.#d,get head(){return t.#u},get tail(){return t.#p},free:t.#g,isBackgroundFetch:e=>t.#A(e),backgroundFetch:(e,i,s,n)=>t.#v(e,i,s,n),moveToTail:e=>t.#k(e),indexes:e=>t.#F(e),rindexes:e=>t.#x(e),isStale:e=>t.#b(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#o}get size(){return this.#a}get fetchMethod(){return this.#h}get dispose(){return this.#s}get disposeAfter(){return this.#n}constructor(t){const{max:e=0,ttl:i,ttlResolution:n=1,ttlAutopurge:h,updateAgeOnGet:a,updateAgeOnHas:o,allowStale:r,dispose:l,disposeAfter:c,noDisposeOnSet:f,noUpdateTTL:d,maxSize:u=0,maxEntrySize:p=0,sizeCalculation:g,fetchMethod:S,noDeleteOnFetchRejection:y,noDeleteOnStaleGet:m,allowStaleOnFetchRejection:z,allowStaleOnFetchAbort:w,ignoreFetchAbort:L}=t;if(e!==0&&!isPosInt(e)){throw new TypeError("max option must be a nonnegative integer")}const _=e?getUintArray(e):Array;if(!_){throw new Error("invalid max value: "+e)}this.#e=e;this.#i=u;this.maxEntrySize=p||this.#i;this.sizeCalculation=g;if(this.sizeCalculation){if(!this.#i&&!this.maxEntrySize){throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize")}if(typeof this.sizeCalculation!=="function"){throw new TypeError("sizeCalculation set to non-function")}}if(S!==undefined&&typeof S!=="function"){throw new TypeError("fetchMethod must be a function if specified")}this.#h=S;this.#L=!!S;this.#r=new Map;this.#l=new Array(e).fill(undefined);this.#c=new Array(e).fill(undefined);this.#f=new _(e);this.#d=new _(e);this.#u=0;this.#p=0;this.#g=Stack.create(e);this.#a=0;this.#o=0;if(typeof l==="function"){this.#s=l}if(typeof c==="function"){this.#n=c;this.#S=[]}else{this.#n=undefined;this.#S=undefined}this.#w=!!this.#s;this.#_=!!this.#n;this.noDisposeOnSet=!!f;this.noUpdateTTL=!!d;this.noDeleteOnFetchRejection=!!y;this.allowStaleOnFetchRejection=!!z;this.allowStaleOnFetchAbort=!!w;this.ignoreFetchAbort=!!L;if(this.maxEntrySize!==0){if(this.#i!==0){if(!isPosInt(this.#i)){throw new TypeError("maxSize must be a positive integer if specified")}}if(!isPosInt(this.maxEntrySize)){throw new TypeError("maxEntrySize must be a positive integer if specified")}this.#T()}this.allowStale=!!r;this.noDeleteOnStaleGet=!!m;this.updateAgeOnGet=!!a;this.updateAgeOnHas=!!o;this.ttlResolution=isPosInt(n)||n===0?n:1;this.ttlAutopurge=!!h;this.ttl=i||0;if(this.ttl){if(!isPosInt(this.ttl)){throw new TypeError("ttl must be a positive integer if specified")}this.#O()}if(this.#e===0&&this.ttl===0&&this.#i===0){throw new TypeError("At least one of max, maxSize, or ttl is required")}if(!this.ttlAutopurge&&!this.#e&&!this.#i){const t="LRU_CACHE_UNBOUNDED";if(shouldWarn(t)){s.add(t);const e="TTL caching without ttlAutopurge, max, or maxSize can "+"result in unbounded memory consumption.";emitWarning(e,"UnboundedCacheWarning",t,LRUCache)}}}getRemainingTTL(t){return this.#r.has(t)?Infinity:0}#O(){const t=new ZeroArray(this.#e);const e=new ZeroArray(this.#e);this.#z=t;this.#m=e;this.#D=(s,n,h=i.now())=>{e[s]=n!==0?h:0;t[s]=n;if(n!==0&&this.ttlAutopurge){const t=setTimeout((()=>{if(this.#b(s)){this.delete(this.#l[s])}}),n+1);if(t.unref){t.unref()}}};this.#E=s=>{e[s]=t[s]!==0?i.now():0};this.#C=(i,n)=>{if(t[n]){const h=t[n];const a=e[n];i.ttl=h;i.start=a;i.now=s||getNow();const o=i.now-a;i.remainingTTL=h-o}};let s=0;const getNow=()=>{const t=i.now();if(this.ttlResolution>0){s=t;const e=setTimeout((()=>s=0),this.ttlResolution);if(e.unref){e.unref()}}return t};this.getRemainingTTL=i=>{const n=this.#r.get(i);if(n===undefined){return 0}const h=t[n];const a=e[n];if(h===0||a===0){return Infinity}const o=(s||getNow())-a;return h-o};this.#b=i=>t[i]!==0&&e[i]!==0&&(s||getNow())-e[i]>t[i]}#E=()=>{};#C=()=>{};#D=()=>{};#b=()=>false;#T(){const t=new ZeroArray(this.#e);this.#o=0;this.#y=t;this.#R=e=>{this.#o-=t[e];t[e]=0};this.#M=(t,e,i,s)=>{if(this.#A(e)){return 0}if(!isPosInt(i)){if(s){if(typeof s!=="function"){throw new TypeError("sizeCalculation must be a function")}i=s(e,t);if(!isPosInt(i)){throw new TypeError("sizeCalculation return invalid (expect positive integer)")}}else{throw new TypeError("invalid size value (must be positive integer). "+"When maxSize or maxEntrySize is used, sizeCalculation "+"or size must be set.")}}return i};this.#I=(e,i,s)=>{t[e]=i;if(this.#i){const i=this.#i-t[e];while(this.#o>i){this.#W(true)}}this.#o+=t[e];if(s){s.entrySize=i;s.totalCalculatedSize=this.#o}}}#R=t=>{};#I=(t,e,i)=>{};#M=(t,e,i,s)=>{if(i||s){throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache")}return 0};*#F({allowStale:t=this.allowStale}={}){if(this.#a){for(let e=this.#p;true;){if(!this.#B(e)){break}if(t||!this.#b(e)){yield e}if(e===this.#u){break}else{e=this.#d[e]}}}}*#x({allowStale:t=this.allowStale}={}){if(this.#a){for(let e=this.#u;true;){if(!this.#B(e)){break}if(t||!this.#b(e)){yield e}if(e===this.#p){break}else{e=this.#f[e]}}}}#B(t){return t!==undefined&&this.#r.get(this.#l[t])===t}*entries(){for(const t of this.#F()){if(this.#c[t]!==undefined&&this.#l[t]!==undefined&&!this.#A(this.#c[t])){yield[this.#l[t],this.#c[t]]}}}*rentries(){for(const t of this.#x()){if(this.#c[t]!==undefined&&this.#l[t]!==undefined&&!this.#A(this.#c[t])){yield[this.#l[t],this.#c[t]]}}}*keys(){for(const t of this.#F()){const e=this.#l[t];if(e!==undefined&&!this.#A(this.#c[t])){yield e}}}*rkeys(){for(const t of this.#x()){const e=this.#l[t];if(e!==undefined&&!this.#A(this.#c[t])){yield e}}}*values(){for(const t of this.#F()){const e=this.#c[t];if(e!==undefined&&!this.#A(this.#c[t])){yield this.#c[t]}}}*rvalues(){for(const t of this.#x()){const e=this.#c[t];if(e!==undefined&&!this.#A(this.#c[t])){yield this.#c[t]}}}[Symbol.iterator](){return this.entries()}find(t,e={}){for(const i of this.#F()){const s=this.#c[i];const n=this.#A(s)?s.__staleWhileFetching:s;if(n===undefined)continue;if(t(n,this.#l[i],this)){return this.get(this.#l[i],e)}}}forEach(t,e=this){for(const i of this.#F()){const s=this.#c[i];const n=this.#A(s)?s.__staleWhileFetching:s;if(n===undefined)continue;t.call(e,n,this.#l[i],this)}}rforEach(t,e=this){for(const i of this.#x()){const s=this.#c[i];const n=this.#A(s)?s.__staleWhileFetching:s;if(n===undefined)continue;t.call(e,n,this.#l[i],this)}}purgeStale(){let t=false;for(const e of this.#x({allowStale:true})){if(this.#b(e)){this.delete(this.#l[e]);t=true}}return t}dump(){const t=[];for(const e of this.#F({allowStale:true})){const s=this.#l[e];const n=this.#c[e];const h=this.#A(n)?n.__staleWhileFetching:n;if(h===undefined||s===undefined)continue;const a={value:h};if(this.#z&&this.#m){a.ttl=this.#z[e];const t=i.now()-this.#m[e];a.start=Math.floor(Date.now()-t)}if(this.#y){a.size=this.#y[e]}t.unshift([s,a])}return t}load(t){this.clear();for(const[e,s]of t){if(s.start){const t=Date.now()-s.start;s.start=i.now()-t}this.set(e,s.value,s)}}set(t,e,i={}){if(e===undefined){this.delete(t);return this}const{ttl:s=this.ttl,start:n,noDisposeOnSet:h=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:o}=i;let{noUpdateTTL:r=this.noUpdateTTL}=i;const l=this.#M(t,e,i.size||0,a);if(this.maxEntrySize&&l>this.maxEntrySize){if(o){o.set="miss";o.maxEntrySizeExceeded=true}this.delete(t);return this}let c=this.#a===0?undefined:this.#r.get(t);if(c===undefined){c=this.#a===0?this.#p:this.#g.length!==0?this.#g.pop():this.#a===this.#e?this.#W(false):this.#a;this.#l[c]=t;this.#c[c]=e;this.#r.set(t,c);this.#f[this.#p]=c;this.#d[c]=this.#p;this.#p=c;this.#a++;this.#I(c,l,o);if(o)o.set="add";r=false}else{this.#k(c);const i=this.#c[c];if(e!==i){if(this.#L&&this.#A(i)){i.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:e}=i;if(e!==undefined&&!h){if(this.#w){this.#s?.(e,t,"set")}if(this.#_){this.#S?.push([e,t,"set"])}}}else if(!h){if(this.#w){this.#s?.(i,t,"set")}if(this.#_){this.#S?.push([i,t,"set"])}}this.#R(c);this.#I(c,l,o);this.#c[c]=e;if(o){o.set="replace";const t=i&&this.#A(i)?i.__staleWhileFetching:i;if(t!==undefined)o.oldValue=t}}else if(o){o.set="update"}}if(s!==0&&!this.#z){this.#O()}if(this.#z){if(!r){this.#D(c,s,n)}if(o)this.#C(o,c)}if(!h&&this.#_&&this.#S){const t=this.#S;let e;while(e=t?.shift()){this.#n?.(...e)}}return this}pop(){try{while(this.#a){const t=this.#c[this.#u];this.#W(true);if(this.#A(t)){if(t.__staleWhileFetching){return t.__staleWhileFetching}}else if(t!==undefined){return t}}}finally{if(this.#_&&this.#S){const t=this.#S;let e;while(e=t?.shift()){this.#n?.(...e)}}}}#W(t){const e=this.#u;const i=this.#l[e];const s=this.#c[e];if(this.#L&&this.#A(s)){s.__abortController.abort(new Error("evicted"))}else if(this.#w||this.#_){if(this.#w){this.#s?.(s,i,"evict")}if(this.#_){this.#S?.push([s,i,"evict"])}}this.#R(e);if(t){this.#l[e]=undefined;this.#c[e]=undefined;this.#g.push(e)}if(this.#a===1){this.#u=this.#p=0;this.#g.length=0}else{this.#u=this.#f[e]}this.#r.delete(i);this.#a--;return e}has(t,e={}){const{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e;const n=this.#r.get(t);if(n!==undefined){const t=this.#c[n];if(this.#A(t)&&t.__staleWhileFetching===undefined){return false}if(!this.#b(n)){if(i){this.#E(n)}if(s){s.has="hit";this.#C(s,n)}return true}else if(s){s.has="stale";this.#C(s,n)}}else if(s){s.has="miss"}return false}peek(t,e={}){const{allowStale:i=this.allowStale}=e;const s=this.#r.get(t);if(s!==undefined&&(i||!this.#b(s))){const t=this.#c[s];return this.#A(t)?t.__staleWhileFetching:t}}#v(t,e,i,s){const n=e===undefined?undefined:this.#c[e];if(this.#A(n)){return n}const a=new h;const{signal:o}=i;o?.addEventListener("abort",(()=>a.abort(o.reason)),{signal:a.signal});const r={signal:a.signal,options:i,context:s};const cb=(s,n=false)=>{const{aborted:h}=a.signal;const o=i.ignoreFetchAbort&&s!==undefined;if(i.status){if(h&&!n){i.status.fetchAborted=true;i.status.fetchError=a.signal.reason;if(o)i.status.fetchAbortIgnored=true}else{i.status.fetchResolved=true}}if(h&&!o&&!n){return fetchFail(a.signal.reason)}const c=l;if(this.#c[e]===l){if(s===undefined){if(c.__staleWhileFetching){this.#c[e]=c.__staleWhileFetching}else{this.delete(t)}}else{if(i.status)i.status.fetchUpdated=true;this.set(t,s,r.options)}}return s};const eb=t=>{if(i.status){i.status.fetchRejected=true;i.status.fetchError=t}return fetchFail(t)};const fetchFail=s=>{const{aborted:n}=a.signal;const h=n&&i.allowStaleOnFetchAbort;const o=h||i.allowStaleOnFetchRejection;const r=o||i.noDeleteOnFetchRejection;const c=l;if(this.#c[e]===l){const i=!r||c.__staleWhileFetching===undefined;if(i){this.delete(t)}else if(!h){this.#c[e]=c.__staleWhileFetching}}if(o){if(i.status&&c.__staleWhileFetching!==undefined){i.status.returnedStale=true}return c.__staleWhileFetching}else if(c.__returned===c){throw s}};const pcall=(e,s)=>{const h=this.#h?.(t,n,r);if(h&&h instanceof Promise){h.then((t=>e(t===undefined?undefined:t)),s)}a.signal.addEventListener("abort",(()=>{if(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort){e(undefined);if(i.allowStaleOnFetchAbort){e=t=>cb(t,true)}}}))};if(i.status)i.status.fetchDispatched=true;const l=new Promise(pcall).then(cb,eb);const c=Object.assign(l,{__abortController:a,__staleWhileFetching:n,__returned:undefined});if(e===undefined){this.set(t,c,{...r.options,status:undefined});e=this.#r.get(t)}else{this.#c[e]=c}return c}#A(t){if(!this.#L)return false;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof h}async fetch(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:h=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:o=0,sizeCalculation:r=this.sizeCalculation,noUpdateTTL:l=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:f=this.allowStaleOnFetchRejection,ignoreFetchAbort:d=this.ignoreFetchAbort,allowStaleOnFetchAbort:u=this.allowStaleOnFetchAbort,context:p,forceRefresh:g=false,status:S,signal:y}=e;if(!this.#L){if(S)S.fetch="get";return this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,status:S})}const m={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,ttl:h,noDisposeOnSet:a,size:o,sizeCalculation:r,noUpdateTTL:l,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:f,allowStaleOnFetchAbort:u,ignoreFetchAbort:d,status:S,signal:y};let z=this.#r.get(t);if(z===undefined){if(S)S.fetch="miss";const e=this.#v(t,z,m,p);return e.__returned=e}else{const e=this.#c[z];if(this.#A(e)){const t=i&&e.__staleWhileFetching!==undefined;if(S){S.fetch="inflight";if(t)S.returnedStale=true}return t?e.__staleWhileFetching:e.__returned=e}const n=this.#b(z);if(!g&&!n){if(S)S.fetch="hit";this.#k(z);if(s){this.#E(z)}if(S)this.#C(S,z);return e}const h=this.#v(t,z,m,p);const a=h.__staleWhileFetching!==undefined;const o=a&&i;if(S){S.fetch=n?"stale":"refresh";if(o&&n)S.returnedStale=true}return o?h.__staleWhileFetching:h.__returned=h}}get(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:h}=e;const a=this.#r.get(t);if(a!==undefined){const e=this.#c[a];const o=this.#A(e);if(h)this.#C(h,a);if(this.#b(a)){if(h)h.get="stale";if(!o){if(!n){this.delete(t)}if(h&&i)h.returnedStale=true;return i?e:undefined}else{if(h&&i&&e.__staleWhileFetching!==undefined){h.returnedStale=true}return i?e.__staleWhileFetching:undefined}}else{if(h)h.get="hit";if(o){return e.__staleWhileFetching}this.#k(a);if(s){this.#E(a)}return e}}else if(h){h.get="miss"}}#U(t,e){this.#d[e]=t;this.#f[t]=e}#k(t){if(t!==this.#p){if(t===this.#u){this.#u=this.#f[t]}else{this.#U(this.#d[t],this.#f[t])}this.#U(this.#p,t);this.#p=t}}delete(t){let e=false;if(this.#a!==0){const i=this.#r.get(t);if(i!==undefined){e=true;if(this.#a===1){this.clear()}else{this.#R(i);const e=this.#c[i];if(this.#A(e)){e.__abortController.abort(new Error("deleted"))}else if(this.#w||this.#_){if(this.#w){this.#s?.(e,t,"delete")}if(this.#_){this.#S?.push([e,t,"delete"])}}this.#r.delete(t);this.#l[i]=undefined;this.#c[i]=undefined;if(i===this.#p){this.#p=this.#d[i]}else if(i===this.#u){this.#u=this.#f[i]}else{this.#f[this.#d[i]]=this.#f[i];this.#d[this.#f[i]]=this.#d[i]}this.#a--;this.#g.push(i)}}}if(this.#_&&this.#S?.length){const t=this.#S;let e;while(e=t?.shift()){this.#n?.(...e)}}return e}clear(){for(const t of this.#x({allowStale:true})){const e=this.#c[t];if(this.#A(e)){e.__abortController.abort(new Error("deleted"))}else{const i=this.#l[t];if(this.#w){this.#s?.(e,i,"delete")}if(this.#_){this.#S?.push([e,i,"delete"])}}}this.#r.clear();this.#c.fill(undefined);this.#l.fill(undefined);if(this.#z&&this.#m){this.#z.fill(0);this.#m.fill(0)}if(this.#y){this.#y.fill(0)}this.#u=0;this.#p=0;this.#g.length=0;this.#o=0;this.#a=0;if(this.#_&&this.#S){const t=this.#S;let e;while(e=t?.shift()){this.#n?.(...e)}}}}e.LRUCache=LRUCache})();module.exports=t})();