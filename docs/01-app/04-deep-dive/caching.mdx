---
title: How caching works in Next.js
nav_title: Caching
description: An deep dive into how caching works in Next.js
---

Caching is a technique for storing the result of rendering, data fetching, and other computations so that future requests for the same data can be served faster, without doing the work again.

In this deep dive, you'll learn:

- [Caching principles](#caching-principles)
- [How caching works in Next.js](#how-caching-works-in-nextjs)
- [How to define cache boundaries with `"use cache"`](#how-use-cache-works)
- How to define update semantics with `cacheLife` and `cacheTag`
- How to configure a remote, persistent cache (coming soon)

## Caching principles

In Next.js, caching is:

- [Client-first](#client-first): The browser is the first place the framework checks before making new requests to the server.
- [Declarative](#declarative): You describe when a cache entry should be updated, not how it's stored.
- [Composable](#composable): You can granularly cache individual route segments, React Server Components, or regular functions.

### Client-first

Next.js uses the same model for client and server caching. When retrieving a cache entry, it checks:

1. The client cache
2. The server in-memory cache
3. A remote persistent cache, if defined

However, **client-first does not mean client-only**. The server still plays a role in fetching and rendering, deduplicating requests, reusing static shells across users, and persisting results to a remote cache.

### Declarative

Caching in Next.js is declarative. You don't configure caching layers and infrastructure directly. Instead:

- You describe how long some data or UI can be reused, when it should be refreshed, and what triggers a revalidation.
- Next.js handles how and where it's cached-during build time or during runtime on [client](#client-cache), [server in-memory](#in-memory-caching-and-deduplication), or [remote persistent cache](#persistent-remote-caching).

### Composable

Next.js caching is granular and composable. You can cache route segments, nested Server Components, and individual functions. And interleave static and dynamic content, only caching what's needed, while keeping dynamic or user-specific parts fresh.

This is specially helpful for:

1. Hybrid pages that combine static and dynamic content.
2. High-cardinality params that generate many unique pages, making prerendering resource-intensive.
3. Personalized content \based on user-specific data available only at request time.

## Caching APIs

The APIs used for caching are:

- [`"use cache"`](#how-use-cache-works): Marks a Server Component or function as cacheable.
- [`cacheLife`](#how-cacheLife-works): Sets when a cache entry should be updated.
- [`cacheTag`](#how-cacheTag-works): Groups entries based on tags to be updated together.

## How `"use cache"` works

`"use cache"` can be placed inside am async [Server Component](https://react.dev/reference/rsc/server-components) or function to mark it as cacheable.

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  'use cache'
  // ...
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  'use cache'
  // ...
}
```

Functions marked with `"use cache"` are compiled into [Server Functions](https://react.dev/reference/rsc/server-functions).

Behind-the-scenes, Next.js:

1. Integrates the Server Function with caching logic.
2. Generates an unique [cache key](#cache-keys).
3. Deduplicates identical calls using React's [`cache`](https://react.dev/reference/react/cache) function.
4. Stores the cache entry in [server memory](#in-memory-caching-and-deduplication) or a persistent, remote cache.
5. Annotates the Server Component payload with [#update-semantics](##update-semantics).
6. Sends the RSC payload to the client where the [client router]() will use the information to manage the cache.

### Cache keys

Each cache boundary creates an unique cache entry, which is generated from:

- The build ID (generated for each build)
- The function signature (a secure identifier)
- Any [serializable](#serialization) arguments or props passed to the function
- Any values it reads from the parent scope

If the inputs passed to the function are different, a new cache entry is created.

For example:

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

### Serialization

The return value of the cacheable function must be [serializable](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values) by React.

If you pass non-serializable values like functions or components, they are excluded from the [cache key](#cache-keys). Instead, they are treated as references and resolved at runtime. This allows [interleaving](#interleaving) dynamic and static content.

### Interleaving dynamic and static content

Interleaving lets you nest dynamic content inside cached components.

For example, you can mark a [layout](/docs/app/api-reference/file-conventions/layout) as cacheable while keeping its page (`{children}`) dynamic:

```tsx filename="app/dashboard/layout.tsx" switcher
function Layout({ children }: { children: React.ReactNode }) {
  'use cache'

  return (
    <div>
      {/* Navigation will be cached */}
      <Navigation />
      {/* Children can be dynamic */}
      {children}
    </div>
  )
}
```

```jsx filename="app/layout.js" switcher
function Layout({ children }: { children: React.ReactNode }) {
  'use cache'

  return (
    <div>
      {/* Navigation will be cached */}
      <Navigation />
      {/* Children can be dynamic */}
      {children}
    </div>
  )
}
```

The same applies for nested Server Components deeper in the tree:

```tsx filename="app/ui/profile.tsx" switcher
async function Profile({ id, children }) {
  'use cache'
  const user = await getUser(id)

  return (
    <>
      {/* Username is cached */}
      <h1>{user.name}</h1>
      {/* Children can be dynamic */}
      {children}
    </>
  )
}
```

```jsx filename="app/ui/profile.js" switcher
async function Profile({ id, children }) {
  'use cache'
  const user = await getUser(id)

  return (
    <>
      {/* Username is cached */}
      <h1>{user.name}</h1>
      {/* Children can be dynamic */}
      {children}
    </>
  )
}
```

**How it works**:

The non-serializable values — like `{children}` props or dynamic nested components — are treated as references and not included in the [cache key](#cache-keys). Instead, these references are filled in at runtime. This prevents the dynamic values from “poisoning” the cache, which would otherwise generate a new cache entry for every variation.

## Server cache

### In-memory caching and deduplication

By default, `"use cache"` uses an in-memory cache on the server. This avoids re-executing expensive operations like database reads or API calls for every cached function invocation.

**How long does it last?**

The in-memory cache only exists while the server is running.

- **Serverless**: the cache lasts for the lifetime of the serverless function.
- **Long-running server**: the cache lasts until the server is restarted or the memory is cleared.

**What is deduplication?**

During a server render pass, Next.js automatically deduplicates functions marked with `"use cache"`. This prevents the same function with the same inputs from being executed multiple times.

**Why in-memory caching?**

The in-memory cache provides a foundational default that:

- Speeds up rendering by accumulating cache entries during a pass.
- Reduces requests to external database or APIs, improving performance and reducing costs.
- Works well as a simple and affordable starting point for [self-hosted]() applications.
