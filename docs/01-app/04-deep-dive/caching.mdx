---
title: How caching works in Next.js
nav_title: Caching
description: An deep dive into how caching works in Next.js
---

Caching is a technique for storing the result of time-consuming work (rendering, data fetching, and other computations) so that future requests for the same content can be served faster, without recomputing the result.

In this deep dive, you’ll learn:

- [How caching works in Next.js](#how-caching-works-in-nextjs)
- [How to define cache boundaries with `"use cache"`](#how-use-cache-works)
- How to define update semantics with `cacheLife` and `cacheTag`
- How to configure a remote, persistent cache (coming soon)

## How caching works in Next.js

In Next.js, caching can be described as:

- [Client-first](#client-first): The browser becomes an active participant in caching, and is the first place Next.js checks for cached data or UI.
- [Declarative](#declarative): You describe when a cache should be updated, rather than how and where the cache is stored.
- [Granular](#granular): You can cache individual route segments, React Server Components, or regular functions, rather than the entire page.

### Client-first

Web frameworks usually treat server and client caching as independent systems.

- Server caching might use HTTP Cache-Control headers to configure external infrastructure (like CDNs) and an in-memory or distributed cache to store computed results.
- Client caching might use client-side libraries with their own cache keys and revalidation strategies.

Next.js uses the same model for **both** the client and server caching. When retrieving a cached entry, it checks:

1. The client cache
2. The server in-memory cache
3. A persistent remote cache, if defined

{/* TODO: Add diagram */}

By making caching **client-first**, we can reduce unnecessary server requests and optimize React Server Component architecture to provide a similar **user experience** as Single-Page Applications (SPAs)—while still leveraging the benefits of doing work on the server.

However, **client-first does not mean client-only**. The server still plays a role in:

- Executing logic when needed (e.g. data fetching and rendering)
- Deduping requests for the same content (in-memory caching)
- Reusing static shells across users
- Persisting the result to a remote cache

In this hybrid model, the client becomes an active participant in caching. For the user, it means faster page transitions and less intermediary loading states. For the developer, it means using one cohesive model for caching across client and server.
