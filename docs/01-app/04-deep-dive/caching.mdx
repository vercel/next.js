---
title: How caching works in Next.js
nav_title: Caching
description: An deep dive into how caching works in Next.js
---

Caching is a technique for storing the result of rendering, data fetching, and other computations so that future requests for the same data can be served faster, without doing the work again.

In this deep dive, you'll learn:

- [Caching principles](#caching-principles)
- [How caching works in Next.js](#how-caching-works-in-nextjs)
- [How to define cache boundaries with `"use cache"`](#how-use-cache-works)
- How to define update semantics with `cacheLife` and `cacheTag`
- How to configure a remote, persistent cache (coming soon)

## Caching principles

In Next.js, caching is:

- [Client-first](#client-first): The browser is the first place the framework checks before making new requests to the server.
- [Declarative](#declarative): You describe when a cache entry should be updated, not how it's stored.
- [Composable](#composable): You can granularly cache individual route segments, React Server Components, or regular functions.

### Client-first

Next.js uses the same model for client and server caching. When retrieving a cache entry, it checks:

1. The client cache
2. The server in-memory cache
3. A remote persistent cache, if defined

However, **client-first does not mean client-only**. The server still plays a role in fetching and rendering, deduplicating requests, reusing static shells across users, and persisting results to a remote cache.

### Declarative

Caching in Next.js is declarative. You don't configure caching layers and infrastructure directly. Instead:

- You describe how long some data or UI can be reused, when it should be refreshed, and what triggers a revalidation.
- Next.js handles how and where it's cached-during build time or during runtime on [client](#client-cache), [server in-memory](#in-memory-caching-and-deduplication), or [remote persistent cache](#persistent-remote-caching).

### Composable

Next.js caching is granular and composable. You can cache route segments, nested Server Components, and individual functions. And interleave static and dynamic content, only caching what's needed, while keeping dynamic or user-specific parts fresh.

This is specially helpful for:

1. Hybrid pages that combine static and dynamic content.
2. High-cardinality params that generate many unique pages, making prerendering resource-intensive.
3. Personalized content \based on user-specific data available only at request time.

## Caching APIs

The APIs used for caching are:

- [`"use cache"`](#how-use-cache-works): Marks a Server Component or function as cacheable.
- [`cacheLife`](#how-cacheLife-works): Sets when a cache entry should be updated.
- [`cacheTag`](#how-cacheTag-works): Groups entries based on tags to be updated together.

## How `"use cache"` works

`"use cache"` can be placed inside am async [Server Component](https://react.dev/reference/rsc/server-components) or function to mark it as cacheable.

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  'use cache'
  // ...
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  'use cache'
  // ...
}
```

Functions marked with `"use cache"` are compiled into [Server Functions](https://react.dev/reference/rsc/server-functions).

Behind-the-scenes, Next.js:

1. Integrates the Server Function with caching logic.
2. Generates an unique [cache key](#cache-keys).
3. Deduplicates identical calls using React's [`cache`](https://react.dev/reference/react/cache) function.
4. Stores the cache entry in [server memory](#in-memory-caching-and-deduplication) or a persistent, remote cache.
5. Annotates the Server Component payload with [#update-semantics](##update-semantics).
6. Sends the RSC payload to the client where the [client router]() will use the information to manage the cache.

### Cache keys

Each cache boundary creates an unique cache entry, which is generated from:

- The build ID (generated for each build)
- The function signature (a secure identifier)
- Any [serializable](#serialization) arguments or props passed to the function
- Any values it reads from the parent scope

If the inputs passed to the function are different, a new cache entry is created.

For example:

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

### Serialization

The return value of the cacheable function must be [serializable](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values) by React.

If you pass non-serializable values like functions or components, they are excluded from the [cache key](#cache-keys). Instead, they are treated as references and resolved at runtime. This allows [interleaving](#interleaving) dynamic and static content.

### Interleaving dynamic and static content

Interleaving lets you nest dynamic content inside cached components.

For example, you can mark a [layout](/docs/app/api-reference/file-conventions/layout) as cacheable while keeping its page (`{children}`) dynamic:

```tsx filename="app/dashboard/layout.tsx" switcher
function Layout({ children }: { children: React.ReactNode }) {
  'use cache'

  return (
    <div>
      {/* Navigation will be cached */}
      <Navigation />
      {/* Children can be dynamic */}
      {children}
    </div>
  )
}
```

```jsx filename="app/layout.js" switcher
function Layout({ children }: { children: React.ReactNode }) {
  'use cache'

  return (
    <div>
      {/* Navigation will be cached */}
      <Navigation />
      {/* Children can be dynamic */}
      {children}
    </div>
  )
}
```

The same applies for nested Server Components deeper in the tree:

```tsx filename="app/ui/profile.tsx" switcher
async function Profile({ id, children }) {
  'use cache'
  const user = await getUser(id)

  return (
    <>
      {/* Username is cached */}
      <h1>{user.name}</h1>
      {/* Children can be dynamic */}
      {children}
    </>
  )
}
```

```jsx filename="app/ui/profile.js" switcher
async function Profile({ id, children }) {
  'use cache'
  const user = await getUser(id)

  return (
    <>
      {/* Username is cached */}
      <h1>{user.name}</h1>
      {/* Children can be dynamic */}
      {children}
    </>
  )
}
```

**How it works**:

The non-serializable values — like `{children}` props or dynamic nested components — are treated as references and not included in the [cache key](#cache-keys). Instead, these references are filled in at runtime. This prevents the dynamic values from “poisoning” the cache, which would otherwise generate a new cache entry for every variation.

The behavior of `"use cache"` depends on when it runs:

- [Prerender](#prerender-build-time) (during build or revalidation)
- [Runtime](#runtime) (resume render)
- [Subsequent requests](#subsequent-requests) (reusing the client cache)

#### Prerender (build time)

At build time, Next.js prerenders functions annotated with `"use cache"`. The result is saved in an internal framework **Resume Data Cache**, which is part of the [Partial Prerendering](/docs/app/building-your-application/rendering/partial-prerendering) architecture.

If a `"use cache"` function uses [`cookies`](/docs/app/api-reference/functions/cookies), it’s marked as dynamic, and skips prerendering. It will only run at runtime, where cookie data is available in the request.

#### Runtime (resume render)

Runtime (resume render) refers to the phase where a user navigates to a route for the first time or the route is prefetched in the background.

At this point, Next.js has [prerendered](#prerender-build-time) some or all of the route, and sends the RSC payload to the client.

- If a `"use cache"` entry was present in the Resume Data Cache, it's reused.
- If it was missing or expired, the function re-runs on the server.
