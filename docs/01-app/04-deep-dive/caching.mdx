---
title: How caching works in Next.js
nav_title: Caching
description: An deep dive into how caching works in Next.js
---

Caching is a technique for storing the result of expensive work (rendering, data fetching, and other computations) so that future requests for the same content can be served faster, without recomputing the result.

In this deep dive, you’ll learn:

- [How caching works in Next.js](#how-caching-works-in-nextjs)
- [How to define cache boundaries with `"use cache"`](#how-use-cache-works)
- How to define update semantics with `cacheLife` and `cacheTag`
- How to configure a remote, persistent cache (coming soon)

## How caching works in Next.js

In Next.js, caching can be described as:

- [Client-first](#client-first): The browser becomes an active participant in caching, and is the first place Next.js checks for cached data or UI.
- [Declarative](#declarative): You describe when a cache should be updated, rather than how and where the cache is stored.
- [Granular](#granular): You can cache components and individual async functions, rather than the entire page.

### Client-first

Historically, web frameworks were primarily concerned with **server-side** caching:

- Cache was coupled to infrastructure (e.g. [ISR](https://vercel.com/docs/incremental-static-regeneration), [Data Cache](https://vercel.com/docs/data-cache), CDNs, etc).
- Pages were described as entirely static or dynamic:
  - Static: Prerendered and cached on the server.
  - Dynamic: Re-rendered at request time.
- Personalized data bypassed caching altogether.

Next.js uses both the client and server environments for caching. When resolving a cache miss, it checks:

1. The client cache (prefetched or previously visited content)
2. The server in-memory cache (Lambda or Node runtime)
3. A persistent remote cache, if defined (e.g. [ISR](https://vercel.com/docs/incremental-static-regeneration) or [Data Cache](https://vercel.com/docs/data-cache))

{/* TODO: Add diagram */}

By making caching **client-first**, we can reduce unnecessary server requests and optimize React Server Components to provide a similar **user experience** as Single-Page Applications (SPAs)—while still leveraging the benefits of doing work on the server. For the user, it means faster navigation and less intermediary loading states like skeletons and spinners.

However, **client-first does not mean client-only**. The server still plays a role in:

- Executing logic when needed (e.g. data fetching and rendering)
- Deduping requests for the same content (in-memory caching)
- Reusing static shells across users (PPR)
- Persisting the result in a remote cache (e.g. ISR, CDN, etc)

In this hybrid model, the client is prioritized, becoming an active participant in improving the navigation experience and reducing server load.

### Declarative

Next.js caching APIs let you describe caching **semantics** instead of caching **mechanics**.

Instead of asking: _"Where should this be cached?"_
You ask: _"When should this cache be updated?"_

In other words:

- You describe the [update semantics](#update-semantics): how long something is fresh, when it should revalidate, and what causes invalidation.
- Next.js determines the most appropriate environment and layer based on your declared semantics.

This declarative and agnostic approach allows Next.js to provide a consistent API regardless of your static or dynamic requirements and infrastructure setup.

### Granular

Modern web applications are **dynamic**, **personalized**, **interactive**, and require a granular approach to caching, specifically for:

1. [**Dynamic route segments**](/docs/app/building-your-application/routing/dynamic-routes) - which can potentially create a large number of unique pages. Trying to prerender or cache all of them on the server can be time-consuming and server-intensive.
2. **Personalized content** - some content can only be fetched after authentication—once a browser session exists and cookies are available.

In Next.js, in addition to caching entire pages, you can more granularly cache:

- Route Segments (e.g. layouts, static shell)
- Nested UI components (e.g. user avatar and name)
- Individual data fetching functions (e.g. `getUser()`)

## Caching APIs

There are three main APIs used for caching:

- [`"use cache"`](#how-use-cache-works): Defines a cache **boundary** for an async Server Component or function.
- [`cacheLife()`](#how-cacheLife-works): Defines the cache lifetime for a component or function.
- [`cacheTag()`](#how-cacheTag-works): Defines a cache tag across multiple boundaries to be invalidated together.

## How `"use cache"` works

`"use cache"` is a Next.js directive you can place inside an async [Server Component](https://react.dev/reference/rsc/server-components) or function to declare a **cache boundary**. This tells Next.js to cache the **return value** of that function or component based on its inputs.

```tsx filename="app/lib/data.ts" switcher
export async function getUser(id: string) {
  'use cache'
  // Fetch data
}
```

```jsx filename="app/lib/data.js" switcher
export async function getUser(id) {
  'use cache'
  // Fetch data
}
```

Similar to React's [`"use server"`](https://react.dev/reference/rsc/use-server) directive, functions annotated with `"use cache"` are compiled into [Server Functions](https://react.dev/reference/rsc/server-functions).

Behind-the-scenes, Next.js:

1. Wraps the Server Function with a [Higher Order Component](https://legacy.reactjs.org/docs/higher-order-components.html) that integrates the necessary caching behaviors.
2. Generates an unique [cache key](#cache-keys) for the entry.
3. Deduplicates identical calls using React’s [`cache`](https://react.dev/reference/react/cache) function.
4. Annotates the Server Component Payload and sends it to the client with the necessary semantics for how it should treat the cached content.

On the client, the payload is reused during navigation—leading to faster page transitions.

### Cache keys

Each cache boundary creates an unique cache entry, which is generated from:

- The build ID (generated for each build)
- The function signature (a secure identifier unique to the function)
- Any [serializable](#serialization) arguments or props passed to the function

If the arguments or props passed to the function are different, a new cache entry is created. For example:

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

### Serialization

The return value of the cacheable function must be [serializable](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values). This ensures that the cached content can be stored and retrieved correctly.

If you pass non-serializable values like functions, event handlers, or symbols, they are excluded from the [cache key](#cache-keys). Instead, they are treated as references and resolved at runtime. This makes it possible to cache a [layout](/docs/app/api-reference/file-conventions/layout) while allowing `{children}` to remain dynamic.

```tsx filename="app/dashboard/layout.tsx" switcher
function Layout({ children }: { children: React.ReactNode }) {
  'use cache'

  return (
    <div>
      {/* Navigation will be cached */}
      <Navigation />
      {/* Children will not be cached */}
      <main>{children}</main>
    </div>
  )
}
```

```jsx filename="app/layout.js" switcher
function Layout({ children }: { children: React.ReactNode }) {
  'use cache'

  return (
    <div>
      {/* Navigation will be cached */}
      <Navigation />
      {/* Children will not be cached */}
      <main>{children}</main>
    </div>
  )
}
```

### Behavior

The behavior of `"use cache"` depends on when it runs:

- [Prerender](#prerender-build-time) (during build or revalidation)
- [Runtime](#runtime) (resume render)
- [Subsequent requests](#subsequent-requests) (reusing the client cache)

#### Prerender (build time)

At build time, Next.js prerenders functions annotated with `"use cache"`. The result is saved in an internal framework **Resume Data Cache**, which is part of the [Partial Prerendering](/docs/app/building-your-application/rendering/partial-prerendering) architecture.

If a `"use cache"` function uses [`cookies`](/docs/app/api-reference/functions/cookies), it’s marked as dynamic, and skips prerendering. It will only run at runtime, where cookie data is available in the request.

#### Runtime (resume render)

Runtime (resume render) refers to the phase where a user navigates to a route for the first time or the route is prefetched in the background.

At this point, Next.js has [prerendered](#prerender-build-time) some or all of the route, and sends the RSC payload to the client.

- If a `"use cache"` entry was present in the Resume Data Cache, it's reused.
- If it was missing or expired, the function re-runs on the server.
