---
title: How caching works in Next.js
nav_title: Caching
description: An deep dive into how caching works in Next.js
---

Caching is a technique for storing the result of rendering, data fetching, and other computations so that future requests for the same data can be served faster, without doing the work again.

In this deep dive, you'll learn:

- [Caching principles](#caching-principles)
- [How caching works in Next.js](#how-caching-works-in-nextjs)
- [How to define cache boundaries with `"use cache"`](#how-use-cache-works)
- How to define update semantics with `cacheLife` and `cacheTag`
- How to configure a remote, persistent cache (coming soon)

## Caching principles

In Next.js, caching is:

- [Client-first](#client-first): The browser is the first place the framework checks before making new requests to the server.
- [Declarative](#declarative): You describe when a cache entry should be updated, not how it's stored.
- [Composable](#composable): You can granularly cache individual route segments, React Server Components, or regular functions, and interleave static and dynamic content.

### Client-first

Next.js uses the same model for client and server caching. When retrieving a cache entry, it checks:

1. The client cache
2. The server in-memory cache
3. A remote persistent cache, if defined

{/* TODO: Add diagram */}

However, **client-first does not mean client-only**. The server still plays a role in:

- Fetching data and rendering as needed
- Deduping requests for the same data
- Reusing static shells across users
- Persisting results to a remote cache

In this hybrid model, we can reduce server requests by reusing previously visited segments, and improve the user experience by [prefetching](/docs/app/building-your-application/optimizing/prefetching) in the background.

For users, it means faster page transitions and fewer loading states. For developers, it means using the same API to manage cache behavior across both client and server.

### Declarative

Caching in Next.js is declarative. You don't configure caching layers and infrastructure directly. Instead:

- You describe when a cache entry should be updated
- Next.js handles how and where it's cached-on the client, server in-memory, or remote persistent cache

### Composable

Modern web applications are dynamic and personalized. They have:

1. **Hybrid pages** that combine static and dynamic content.
2. **High-cardinality params** that generate many unique pages, making prerendering resource-intensive.
3. **Personalized content** based on user-specific data available only at request time.

Next.js caching is granular and composable. You can cache:

- Route Segments
- Nested Server Components
- Individual functions

This lets you cache only what's needed, while keeping dynamic or user-specific parts fresh—without applying a single strategy across the entire page or app.

## Caching APIs

There are three main APIs used for caching:

- [`"use cache"`](#how-use-cache-works): Defines a cache **boundary** for an async Server Component or function.
- [`cacheLife()`](#how-cacheLife-works): Defines the cache lifetime for a component or function.
- [`cacheTag()`](#how-cacheTag-works): Defines a cache tag across multiple boundaries to be invalidated together.

## How `"use cache"` works

`"use cache"` is a Next.js directive you can place inside an async [Server Component](https://react.dev/reference/rsc/server-components) or function to declare a **cache boundary**. This tells Next.js to cache the **return value** of that function or component based on its inputs.

```tsx filename="app/lib/data.ts" switcher
export async function getUser(id: string) {
  'use cache'
  // Fetch data
}
```

```jsx filename="app/lib/data.js" switcher
export async function getUser(id) {
  'use cache'
  // Fetch data
}
```

Similar to React's [`"use server"`](https://react.dev/reference/rsc/use-server) directive, functions annotated with `"use cache"` are compiled into [Server Functions](https://react.dev/reference/rsc/server-functions).

Behind-the-scenes, Next.js:

1. Wraps the Server Function with a [Higher Order Component](https://legacy.reactjs.org/docs/higher-order-components.html) that integrates the necessary caching behaviors.
2. Generates an unique [cache key](#cache-keys) for the entry.
3. Deduplicates identical calls using React’s [`cache`](https://react.dev/reference/react/cache) function.
4. Annotates the Server Component Payload and sends it to the client with the necessary semantics for how it should treat the cached content.

On the client, the payload is reused during navigation—leading to faster page transitions.

### Cache keys

Each cache boundary creates an unique cache entry, which is generated from:

- The build ID (generated for each build)
- The function signature (a secure identifier unique to the function)
- Any [serializable](#serialization) arguments or props passed to the function

If the arguments or props passed to the function are different, a new cache entry is created. For example:

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

```tsx filename="app/lib/data.ts" switcher
// Same user ID = cache hit
// Different user ID = new entry

export async function getUser(id: string) {
  'use cache'
  return db.getUser(id)
}
```

### Serialization

The return value of the cacheable function must be [serializable](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values). This ensures that the cached content can be stored and retrieved correctly.

If you pass non-serializable values like functions, event handlers, or symbols, they are excluded from the [cache key](#cache-keys). Instead, they are treated as references and resolved at runtime. This makes it possible to cache a [layout](/docs/app/api-reference/file-conventions/layout) while allowing `{children}` to remain dynamic.

```tsx filename="app/dashboard/layout.tsx" switcher
function Layout({ children }: { children: React.ReactNode }) {
  'use cache'

  return (
    <div>
      {/* Navigation will be cached */}
      <Navigation />
      {/* Children will not be cached */}
      <main>{children}</main>
    </div>
  )
}
```

```jsx filename="app/layout.js" switcher
function Layout({ children }: { children: React.ReactNode }) {
  'use cache'

  return (
    <div>
      {/* Navigation will be cached */}
      <Navigation />
      {/* Children will not be cached */}
      <main>{children}</main>
    </div>
  )
}
```

### Behavior

The behavior of `"use cache"` depends on when it runs:

- [Prerender](#prerender-build-time) (during build or revalidation)
- [Runtime](#runtime) (resume render)
- [Subsequent requests](#subsequent-requests) (reusing the client cache)

#### Prerender (build time)

At build time, Next.js prerenders functions annotated with `"use cache"`. The result is saved in an internal framework **Resume Data Cache**, which is part of the [Partial Prerendering](/docs/app/building-your-application/rendering/partial-prerendering) architecture.

If a `"use cache"` function uses [`cookies`](/docs/app/api-reference/functions/cookies), it’s marked as dynamic, and skips prerendering. It will only run at runtime, where cookie data is available in the request.

#### Runtime (resume render)

Runtime (resume render) refers to the phase where a user navigates to a route for the first time or the route is prefetched in the background.

At this point, Next.js has [prerendered](#prerender-build-time) some or all of the route, and sends the RSC payload to the client.

- If a `"use cache"` entry was present in the Resume Data Cache, it's reused.
- If it was missing or expired, the function re-runs on the server.
