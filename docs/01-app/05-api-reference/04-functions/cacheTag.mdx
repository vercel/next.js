---
title: cacheTag
description: Learn how to use the cacheTag function to manage cache invalidation in your Next.js application.
version: canary
related:
  title: Related
  description: View related API references.
  links:
    - app/api-reference/config/next-config-js/dynamicIO
    - app/api-reference/directives/use-cache
    - app/api-reference/functions/revalidateTag
    - app/api-reference/functions/cacheLife
---

The `cacheTag` function allows you to tag cached data for on-demand invalidation. By associating tags with cache entries, you can selectively purge or revalidate specific cache entries without affecting other cached data.

## Usage

To use `cacheTag`, enable the [`useCache` flag](/docs/app/api-reference/config/next-config-js/useCache) in your `next.config.js` file:

```ts filename="next.config.ts" switcher
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    useCache: true,
  },
}

export default nextConfig
```

```js filename="next.config.js" switcher
const nextConfig = {
  experimental: {
    useCache: true,
  },
}

export default nextConfig
```

The `cacheTag` function takes a single or multiple string values.

```tsx filename="app/data.ts" switcher
import { unstable_cacheTag as cacheTag } from 'next/cache'

export async function getData() {
  'use cache'
  cacheTag('my-data')
  const data = await fetch('/api/data')
  return data
}
```

```jsx filename="app/data.js" switcher
import { unstable_cacheTag as cacheTag } from 'next/cache'

export async function getData() {
  'use cache'
  cacheTag('my-data')
  const data = await fetch('/api/data')
  return data
}
```

You can then purge the cache entry using the [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) API in another function such as a [Route Handler](#invalidating-tags-in-a-route-handler) or [Server Action](#invalidating-tags-in-a-server-action).

## Single and multiple tags

- **Idempotent Tags**: Applying the same tag multiple times has no additional effect.
- **Multiple Tags**: You can assign multiple tags to a single cache entry by passing comma separated values.

```tsx
cacheTag('tag-one', 'tag-two')
```

## Examples

### Tagging components or functions

Tag your cached data by calling `cacheTag` within a cached function or component:

```tsx filename="app/components/bookings.tsx" switcher
import { unstable_cacheTag as cacheTag } from 'next/cache'

interface BookingsProps {
  type: string
}

export async function Bookings({ type = 'haircut' }: BookingsProps) {
  'use cache'
  cacheTag('bookings-data')

  async function getBookingsData() {
    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)
    return data
  }

  return //...
}
```

```jsx filename="app/components/bookings.js" switcher
import { unstable_cacheTag as cacheTag } from 'next/cache'

export async function Bookings({ type = 'haircut' }) {
  'use cache'
  cacheTag('bookings-data')

  async function getBookingsData() {
    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)
    return data
  }

  return //...
}
```

### Creating tags from external data

You can use the data returned from an async function to tag the cache entry.

```tsx filename="app/components/bookings.tsx" switcher
import { unstable_cacheTag as cacheTag } from 'next/cache'

interface BookingsProps {
  type: string
}

export async function Bookings({ type = 'haircut' }: BookingsProps) {
  async function getBookingsData() {
    'use cache'
    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)
    cacheTag('bookings-data', data.id)
    return data
  }
  return //...
}
```

```jsx filename="app/components/bookings.js" switcher
import { unstable_cacheTag as cacheTag } from 'next/cache'

export async function Bookings({ type = 'haircut' }) {
  async function getBookingsData() {
    'use cache'
    const data = await fetch(`/api/bookings?type=${encodeURIComponent(type)}`)
    cacheTag('bookings-data', data.id)
    return data
  }
  return //...
}
```

### Invalidating tags in a Server Action

You can use [Server Actions](/docs/app/getting-started/updating-data#creating-server-functions) to invalidate tags with `revalidateTag`. This is commonly used with form submissions or when updating data.

```tsx filename="app/actions.ts" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function updatePost(formData: FormData) {
  const id = formData.get('id')
  // ...
  // Update post data

  revalidateTag(`post-${id}`)
}
```

```jsx filename="app/actions.js" switcher
'use server'

import { revalidateTag } from 'next/cache'

export async function updatePost(formData) {
  const id = formData.get('id')
  // ...
  // Update post data

  revalidateTag(`post-${id}`)
}
```

### Invalidating tags in a Route Handler

You can use [Route Handlers](/docs/app/building-your-application/routing/route-handlers) to invalidate tags as a response to an external event, such as a webhook from a Content Management System (CMS) when a post is updated. After handling the webhook, you can invalidate the tag with `revalidateTag`.

```tsx filename="app/webhooks/posts/route.ts" switcher
import { revalidateTag } from 'next/cache'

export async function POST(request: Request) {
  // Validate the request is from a trusted source
  // ...
  const { id } = await request.json()
  revalidateTag(`post-${id}`)
  return Response.json({ success: true })
}
```

```jsx filename="app/webhooks/posts/route.js" switcher
import { revalidateTag } from 'next/cache'

export async function POST(request) {
  // Validate the request is from a trusted source
  // ...
  const { id } = await request.json()
  revalidateTag(`post-${id}`)
  return Response.json({ success: true })
}
```
