{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared/runtime-utils.ts"],"sourcesContent":["/**\n * This file contains runtime types and functions that are shared between all\n * TurboPack ECMAScript runtimes.\n *\n * It will be prepended to the runtime code of each runtime.\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"./runtime-types.d.ts\" />\n\ntype EsmNamespaceObject = Record<string, any>\n\n// @ts-ignore Defined in `dev-base.ts`\ndeclare function getOrInstantiateModuleFromParent<M>(\n  id: ModuleId,\n  sourceModule: M\n): M\n\nconst REEXPORTED_OBJECTS = Symbol('reexported objects')\n\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\n\ninterface ModuleContextEntry {\n  id: () => ModuleId\n  module: () => any\n}\n\ninterface ModuleContext {\n  // require call\n  (moduleId: ModuleId): Exports | EsmNamespaceObject\n\n  // async import call\n  import(moduleId: ModuleId): Promise<Exports | EsmNamespaceObject>\n\n  keys(): ModuleId[]\n\n  resolve(moduleId: ModuleId): ModuleId\n}\n\ntype GetOrInstantiateModuleFromParent<M> = (\n  moduleId: ModuleId,\n  parentModule: M\n) => M\n\ndeclare function getOrInstantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\n\nfunction defineProp(\n  obj: any,\n  name: PropertyKey,\n  options: PropertyDescriptor & ThisType<any>\n) {\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\n}\n\n/**\n * Adds the getters to the exports object.\n */\nfunction esm(\n  exports: Exports,\n  getters: Record<string, (() => any) | [() => any, (v: any) => void]>\n) {\n  defineProp(exports, '__esModule', { value: true })\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\n  for (const key in getters) {\n    const item = getters[key]\n    if (Array.isArray(item)) {\n      defineProp(exports, key, {\n        get: item[0],\n        set: item[1],\n        enumerable: true,\n      })\n    } else {\n      defineProp(exports, key, { get: item, enumerable: true })\n    }\n  }\n  Object.seal(exports)\n}\n\n/**\n * Makes the module an ESM with exports\n */\nfunction esmExport(\n  module: Module,\n  exports: Exports,\n  getters: Record<string, () => any>\n) {\n  module.namespaceObject = module.exports\n  esm(exports, getters)\n}\n\nfunction ensureDynamicExports(module: Module, exports: Exports) {\n  let reexportedObjects = module[REEXPORTED_OBJECTS]\n\n  if (!reexportedObjects) {\n    reexportedObjects = module[REEXPORTED_OBJECTS] = []\n    module.exports = module.namespaceObject = new Proxy(exports, {\n      get(target, prop) {\n        if (\n          hasOwnProperty.call(target, prop) ||\n          prop === 'default' ||\n          prop === '__esModule'\n        ) {\n          return Reflect.get(target, prop)\n        }\n        for (const obj of reexportedObjects!) {\n          const value = Reflect.get(obj, prop)\n          if (value !== undefined) return value\n        }\n        return undefined\n      },\n      ownKeys(target) {\n        const keys = Reflect.ownKeys(target)\n        for (const obj of reexportedObjects!) {\n          for (const key of Reflect.ownKeys(obj)) {\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\n          }\n        }\n        return keys\n      },\n    })\n  }\n}\n\n/**\n * Dynamically exports properties from an object\n */\nfunction dynamicExport(\n  module: Module,\n  exports: Exports,\n  object: Record<string, any>\n) {\n  ensureDynamicExports(module, exports)\n\n  if (typeof object === 'object' && object !== null) {\n    module[REEXPORTED_OBJECTS]!.push(object)\n  }\n}\n\nfunction exportValue(module: Module, value: any) {\n  module.exports = value\n}\n\nfunction exportNamespace(module: Module, namespace: any) {\n  module.exports = module.namespaceObject = namespace\n}\n\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\n  return () => obj[key]\n}\n\n/**\n * @returns prototype of the object\n */\nconst getProto: (obj: any) => any = Object.getPrototypeOf\n  ? (obj) => Object.getPrototypeOf(obj)\n  : (obj) => obj.__proto__\n\n/** Prototypes that are not expanded for exports */\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\n\n/**\n * @param raw\n * @param ns\n * @param allowExportDefault\n *   * `false`: will have the raw module as default export\n *   * `true`: will have the default property as default export\n */\nfunction interopEsm(\n  raw: Exports,\n  ns: EsmNamespaceObject,\n  allowExportDefault?: boolean\n) {\n  const getters: { [s: string]: () => any } = Object.create(null)\n  for (\n    let current = raw;\n    (typeof current === 'object' || typeof current === 'function') &&\n    !LEAF_PROTOTYPES.includes(current);\n    current = getProto(current)\n  ) {\n    for (const key of Object.getOwnPropertyNames(current)) {\n      getters[key] = createGetter(raw, key)\n    }\n  }\n\n  // this is not really correct\n  // we should set the `default` getter if the imported module is a `.cjs file`\n  if (!(allowExportDefault && 'default' in getters)) {\n    getters['default'] = () => raw\n  }\n\n  esm(ns, getters)\n  return ns\n}\n\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\n  if (typeof raw === 'function') {\n    return function (this: any, ...args: any[]) {\n      return raw.apply(this, args)\n    }\n  } else {\n    return Object.create(null)\n  }\n}\n\nfunction esmImport(\n  sourceModule: Module,\n  id: ModuleId\n): Exclude<Module['namespaceObject'], undefined> {\n  const module = getOrInstantiateModuleFromParent(id, sourceModule)\n  if (module.error) throw module.error\n\n  // any ES module has to have `module.namespaceObject` defined.\n  if (module.namespaceObject) return module.namespaceObject\n\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n  const raw = module.exports\n  return (module.namespaceObject = interopEsm(\n    raw,\n    createNS(raw),\n    raw && (raw as any).__esModule\n  ))\n}\n\n// Add a simple runtime require so that environments without one can still pass\n// `typeof require` CommonJS checks so that exports are correctly registered.\nconst runtimeRequire =\n  // @ts-ignore\n  typeof require === 'function'\n    ? // @ts-ignore\n      require\n    : function require() {\n        throw new Error('Unexpected use of runtime require')\n      }\n\nfunction commonJsRequire(sourceModule: Module, id: ModuleId): Exports {\n  const module = getOrInstantiateModuleFromParent(id, sourceModule)\n  if (module.error) throw module.error\n  return module.exports\n}\n\n/**\n * `require.context` and require/import expression runtime.\n */\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\n  function moduleContext(id: ModuleId): Exports {\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].module()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.keys = (): ModuleId[] => {\n    return Object.keys(map)\n  }\n\n  moduleContext.resolve = (id: ModuleId): ModuleId => {\n    if (hasOwnProperty.call(map, id)) {\n      return map[id].id()\n    }\n\n    const e = new Error(`Cannot find module '${id}'`)\n    ;(e as any).code = 'MODULE_NOT_FOUND'\n    throw e\n  }\n\n  moduleContext.import = async (id: ModuleId) => {\n    return await (moduleContext(id) as Promise<Exports>)\n  }\n\n  return moduleContext\n}\n\n/**\n * Returns the path of a chunk defined by its data.\n */\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\n}\n\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\n  return (\n    maybePromise != null &&\n    typeof maybePromise === 'object' &&\n    'then' in maybePromise &&\n    typeof maybePromise.then === 'function'\n  )\n}\n\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\n  return turbopackQueues in obj\n}\n\nfunction createPromise<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason?: any) => void\n\n  const promise = new Promise<T>((res, rej) => {\n    reject = rej\n    resolve = res\n  })\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  }\n}\n\n// everything below is adapted from webpack\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n\nconst turbopackQueues = Symbol('turbopack queues')\nconst turbopackExports = Symbol('turbopack exports')\nconst turbopackError = Symbol('turbopack error')\n\nconst enum QueueStatus {\n  Unknown = -1,\n  Unresolved = 0,\n  Resolved = 1,\n}\n\ntype AsyncQueueFn = (() => void) & { queueCount: number }\ntype AsyncQueue = AsyncQueueFn[] & {\n  status: QueueStatus\n}\n\nfunction resolveQueue(queue?: AsyncQueue) {\n  if (queue && queue.status !== QueueStatus.Resolved) {\n    queue.status = QueueStatus.Resolved\n    queue.forEach((fn) => fn.queueCount--)\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\n  }\n}\n\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\n\ntype AsyncModuleExt = {\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\n  [turbopackExports]: Exports\n  [turbopackError]?: any\n}\n\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\n\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\n  return deps.map((dep): AsyncModuleExt => {\n    if (dep !== null && typeof dep === 'object') {\n      if (isAsyncModuleExt(dep)) return dep\n      if (isPromise(dep)) {\n        const queue: AsyncQueue = Object.assign([], {\n          status: QueueStatus.Unresolved,\n        })\n\n        const obj: AsyncModuleExt = {\n          [turbopackExports]: {},\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\n        }\n\n        dep.then(\n          (res) => {\n            obj[turbopackExports] = res\n            resolveQueue(queue)\n          },\n          (err) => {\n            obj[turbopackError] = err\n            resolveQueue(queue)\n          }\n        )\n\n        return obj\n      }\n    }\n\n    return {\n      [turbopackExports]: dep,\n      [turbopackQueues]: () => {},\n    }\n  })\n}\n\nfunction asyncModule(\n  module: Module,\n  body: (\n    handleAsyncDependencies: (\n      deps: Dep[]\n    ) => Exports[] | Promise<() => Exports[]>,\n    asyncResult: (err?: any) => void\n  ) => void,\n  hasAwait: boolean\n) {\n  const queue: AsyncQueue | undefined = hasAwait\n    ? Object.assign([], { status: QueueStatus.Unknown })\n    : undefined\n\n  const depQueues: Set<AsyncQueue> = new Set()\n\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\n\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\n    [turbopackExports]: module.exports,\n    [turbopackQueues]: (fn) => {\n      queue && fn(queue)\n      depQueues.forEach(fn)\n      promise['catch'](() => {})\n    },\n  } satisfies AsyncModuleExt)\n\n  const attributes: PropertyDescriptor = {\n    get(): any {\n      return promise\n    },\n    set(v: any) {\n      // Calling `esmExport` leads to this.\n      if (v !== promise) {\n        promise[turbopackExports] = v\n      }\n    },\n  }\n\n  Object.defineProperty(module, 'exports', attributes)\n  Object.defineProperty(module, 'namespaceObject', attributes)\n\n  function handleAsyncDependencies(deps: Dep[]) {\n    const currentDeps = wrapDeps(deps)\n\n    const getResult = () =>\n      currentDeps.map((d) => {\n        if (d[turbopackError]) throw d[turbopackError]\n        return d[turbopackExports]\n      })\n\n    const { promise, resolve } = createPromise<() => Exports[]>()\n\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\n      queueCount: 0,\n    })\n\n    function fnQueue(q: AsyncQueue) {\n      if (q !== queue && !depQueues.has(q)) {\n        depQueues.add(q)\n        if (q && q.status === QueueStatus.Unresolved) {\n          fn.queueCount++\n          q.push(fn)\n        }\n      }\n    }\n\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\n\n    return fn.queueCount ? promise : getResult()\n  }\n\n  function asyncResult(err?: any) {\n    if (err) {\n      reject((promise[turbopackError] = err))\n    } else {\n      resolve(promise[turbopackExports])\n    }\n\n    resolveQueue(queue)\n  }\n\n  body(handleAsyncDependencies, asyncResult)\n\n  if (queue && queue.status === QueueStatus.Unknown) {\n    queue.status = QueueStatus.Unresolved\n  }\n}\n\n/**\n * A pseudo \"fake\" URL object to resolve to its relative path.\n *\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n * hydration mismatch.\n *\n * This is based on webpack's existing implementation:\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n */\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\n  const realUrl = new URL(inputUrl, 'x:/')\n  const values: Record<string, any> = {}\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\n  values.href = inputUrl\n  values.pathname = inputUrl.replace(/[?#].*/, '')\n  values.origin = values.protocol = ''\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\n  for (const key in values)\n    Object.defineProperty(this, key, {\n      enumerable: true,\n      configurable: true,\n      value: values[key],\n    })\n}\n\nrelativeURL.prototype = URL.prototype\n\n/**\n * Utility function to ensure all variants of an enum are handled.\n */\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\n  throw new Error(`Invariant: ${computeMessage(never)}`)\n}\n\n/**\n * A stub function to make `require` available but non-functional in ESM.\n */\nfunction requireStub(_moduleId: ModuleId): never {\n  throw new Error('dynamic usage of require is not supported')\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/base-externals-utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../shared/runtime-utils.ts\" />\n\n/// A 'base' utilities to support runtime can have externals.\n/// Currently this is for node.js / edge runtime both.\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\n\nasync function externalImport(id: ModuleId) {\n  let raw\n  try {\n    raw = await import(id)\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`)\n  }\n\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\n    return interopEsm(raw.default, createNS(raw), true)\n  }\n\n  return raw\n}\n\nfunction externalRequire(\n  id: ModuleId,\n  thunk: () => any,\n  esm: boolean = false\n): Exports | EsmNamespaceObject {\n  let raw\n  try {\n    raw = thunk()\n  } catch (err) {\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\n    // an external module we don't provide a shim for (e.g. querystring, url).\n    // For now, we fail semi-silently, but in the future this should be a\n    // compilation error.\n    throw new Error(`Failed to load external module ${id}: ${err}`)\n  }\n\n  if (!esm || raw.__esModule) {\n    return raw\n  }\n\n  return interopEsm(raw, createNS(raw), true)\n}\n\nexternalRequire.resolve = (\n  id: string,\n  options?: {\n    paths?: string[]\n  }\n) => {\n  return require.resolve(id, options)\n}\n"],"names":[],"mappings":"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAY;AACxC,IAAI;AACJ,IAAI;AACF,MAAM,MAAM,MAAM,CAAC;AACrB,EAAE,OAAO,KAAK;AACZ,0EAA0E;AAC1E,0EAA0E;AAC1E,qEAAqE;AACrE,qBAAqB;AACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;AAChE;AAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;AACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;AAChD;AAEA,OAAO;AACT;AAEA,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;AAEpB,IAAI;AACJ,IAAI;AACF,MAAM;AACR,EAAE,OAAO,KAAK;AACZ,0EAA0E;AAC1E,0EAA0E;AAC1E,qEAAqE;AACrE,qBAAqB;AACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;AAChE;AAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;AAC1B,OAAO;AACT;AAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;AAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 376, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/node-externals-utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\ndeclare var RUNTIME_PUBLIC_PATH: string\ndeclare var RELATIVE_ROOT_PATH: string\ndeclare var ASSET_PREFIX: string\n\nconst path = require('path')\n\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.')\n// Compute the relative path to the `distDir`.\nconst relativePathToDistRoot = path.join(\n  relativePathToRuntimeRoot,\n  RELATIVE_ROOT_PATH\n)\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot)\n// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\nconst ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot)\n\n/**\n * Returns an absolute path to the given module path.\n * Module path should be relative, either path to a file or a directory.\n *\n * This fn allows to calculate an absolute path for some global static values, such as\n * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\n * See ImportMetaBinding::code_generation for the usage.\n */\nfunction resolveAbsolutePath(modulePath?: string): string {\n  if (modulePath) {\n    return path.join(ABSOLUTE_ROOT, modulePath)\n  }\n  return ABSOLUTE_ROOT\n}\n"],"names":[],"mappings":"AAAA,oDAAoD,GAMpD,MAAM,OAAO,QAAQ;AAErB,MAAM,4BAA4B,KAAK,QAAQ,CAAC,qBAAqB;AACrE,8CAA8C;AAC9C,MAAM,yBAAyB,KAAK,IAAI,CACtC,2BACA;AAEF,MAAM,eAAe,KAAK,OAAO,CAAC,YAAY;AAC9C,mGAAmG;AACnG,MAAM,gBAAgB,KAAK,OAAO,CAAC,YAAY;AAE/C;;;;;;;CAOC,GACD,SAAS,oBAAoB,UAAmB;AAC9C,IAAI,YAAY;AACd,OAAO,KAAK,IAAI,CAAC,eAAe;AAClC;AACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 396, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/shared-node/node-wasm-utils.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../shared/runtime-utils.ts\" />\n\nfunction readWebAssemblyAsResponse(path: string) {\n  const { createReadStream } = require('fs') as typeof import('fs')\n  const { Readable } = require('stream') as typeof import('stream')\n\n  const stream = createReadStream(path)\n\n  // @ts-ignore unfortunately there's a slight type mismatch with the stream.\n  return new Response(Readable.toWeb(stream), {\n    headers: {\n      'content-type': 'application/wasm',\n    },\n  })\n}\n\nasync function compileWebAssemblyFromPath(\n  path: string\n): Promise<WebAssembly.Module> {\n  const response = readWebAssemblyAsResponse(path)\n\n  return await WebAssembly.compileStreaming(response)\n}\n\nasync function instantiateWebAssemblyFromPath(\n  path: string,\n  importsObj: WebAssembly.Imports\n): Promise<Exports> {\n  const response = readWebAssemblyAsResponse(path)\n\n  const { instance } = await WebAssembly.instantiateStreaming(\n    response,\n    importsObj\n  )\n\n  return instance.exports\n}\n"],"names":[],"mappings":"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,SAAS,0BAA0B,IAAY;AAC7C,MAAM,EAAE,gBAAgB,EAAE,GAAG,QAAQ;AACrC,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ;AAE7B,MAAM,SAAS,iBAAiB;AAEhC,2EAA2E;AAC3E,OAAO,IAAI,SAAS,SAAS,KAAK,CAAC,SAAS;AAC1C,SAAS;AACP,gBAAgB;AAClB;AACF;AACF;AAEA,eAAe,2BACb,IAAY;AAEZ,MAAM,WAAW,0BAA0B;AAE3C,OAAO,MAAM,YAAY,gBAAgB,CAAC;AAC5C;AAEA,eAAe,+BACb,IAAY,EACZ,UAA+B;AAE/B,MAAM,WAAW,0BAA0B;AAE3C,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,oBAAoB,CACzD,UACA;AAGF,OAAO,SAAS,OAAO;AACzB","ignoreList":[0]}},
    {"offset": {"line": 417, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack]/nodejs/runtime.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/// <reference path=\"../shared/runtime-utils.ts\" />\n/// <reference path=\"../shared-node/base-externals-utils.ts\" />\n/// <reference path=\"../shared-node/node-externals-utils.ts\" />\n/// <reference path=\"../shared-node/node-wasm-utils.ts\" />\n\nenum SourceType {\n  /**\n   * The module was instantiated because it was included in an evaluated chunk's\n   * runtime.\n   */\n  Runtime = 0,\n  /**\n   * The module was instantiated because a parent module imported it.\n   */\n  Parent = 1,\n}\n\ntype SourceInfo =\n  | {\n      type: SourceType.Runtime\n      chunkPath: ChunkPath\n    }\n  | {\n      type: SourceType.Parent\n      parentId: ModuleId\n    }\n\nprocess.env.TURBOPACK = '1'\n\nfunction stringifySourceInfo(source: SourceInfo): string {\n  switch (source.type) {\n    case SourceType.Runtime:\n      return `runtime for chunk ${source.chunkPath}`\n    case SourceType.Parent:\n      return `parent module ${source.parentId}`\n    default:\n      invariant(source, (source) => `Unknown source type: ${source?.type}`)\n  }\n}\n\ntype ExternalRequire = (\n  id: ModuleId,\n  thunk: () => any,\n  esm?: boolean\n) => Exports | EsmNamespaceObject\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>\n\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\n  R: ResolvePathFromModule\n  x: ExternalRequire\n  y: ExternalImport\n}\n\ntype ModuleFactory = (\n  this: Module['exports'],\n  context: TurbopackNodeBuildContext\n) => undefined\n\nconst url = require('url') as typeof import('url')\nconst fs = require('fs/promises') as typeof import('fs/promises')\n\nconst moduleFactories: ModuleFactories = Object.create(null)\nconst moduleCache: ModuleCache<Module> = Object.create(null)\n\n/**\n * Returns an absolute path to the given module's id.\n */\nfunction createResolvePathFromModule(\n  resolver: (moduleId: string) => Exports\n): (moduleId: string) => string {\n  return function resolvePathFromModule(moduleId: string): string {\n    const exported = resolver(moduleId)\n    const exportedPath = exported?.default ?? exported\n    if (typeof exportedPath !== 'string') {\n      return exported as any\n    }\n\n    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\n    const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\n\n    return url.pathToFileURL(resolved).href\n  }\n}\n\nfunction loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\n  if (typeof chunkData === 'string') {\n    return loadChunkPath(chunkData, source)\n  } else {\n    return loadChunkPath(chunkData.path, source)\n  }\n}\n\nconst loadedChunks = new Set<ChunkPath>()\n\nfunction loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\n  if (!isJs(chunkPath)) {\n    // We only support loading JS chunks in Node.js.\n    // This branch can be hit when trying to load a CSS chunk.\n    return\n  }\n\n  if (loadedChunks.has(chunkPath)) {\n    return\n  }\n\n  try {\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n    const chunkModules: ModuleFactories = require(resolved)\n\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\n      if (!moduleFactories[moduleId]) {\n        moduleFactories[moduleId] = moduleFactory\n      }\n    }\n    loadedChunks.add(chunkPath)\n  } catch (e) {\n    let errorMessage = `Failed to load chunk ${chunkPath}`\n\n    if (source) {\n      errorMessage += ` from ${stringifySourceInfo(source)}`\n    }\n\n    throw new Error(errorMessage, {\n      cause: e,\n    })\n  }\n}\n\nasync function loadChunkAsync(\n  source: SourceInfo,\n  chunkData: ChunkData\n): Promise<any> {\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\n  if (!isJs(chunkPath)) {\n    // We only support loading JS chunks in Node.js.\n    // This branch can be hit when trying to load a CSS chunk.\n    return\n  }\n\n  if (loadedChunks.has(chunkPath)) {\n    return\n  }\n\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n\n  try {\n    const contents = await fs.readFile(resolved, 'utf-8')\n\n    const localRequire = (id: string) => {\n      let resolvedId = require.resolve(id, { paths: [path.dirname(resolved)] })\n      return require(resolvedId)\n    }\n    const module = {\n      exports: {},\n    }\n    // TODO: Use vm.runInThisContext once our minimal supported Node.js version includes https://github.com/nodejs/node/pull/52153\n    // eslint-disable-next-line no-eval -- Can't use vm.runInThisContext due to https://github.com/nodejs/node/issues/52102\n    ;(0, eval)(\n      '(function(module, exports, require, __dirname, __filename) {' +\n        contents +\n        '\\n})' +\n        '\\n//# sourceURL=' +\n        url.pathToFileURL(resolved)\n    )(module, module.exports, localRequire, path.dirname(resolved), resolved)\n\n    const chunkModules: ModuleFactories = module.exports\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\n      if (!moduleFactories[moduleId]) {\n        moduleFactories[moduleId] = moduleFactory\n      }\n    }\n    loadedChunks.add(chunkPath)\n  } catch (e) {\n    let errorMessage = `Failed to load chunk ${chunkPath}`\n\n    if (source) {\n      errorMessage += ` from ${stringifySourceInfo(source)}`\n    }\n\n    throw new Error(errorMessage, {\n      cause: e,\n    })\n  }\n}\n\nasync function loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\n  return loadChunkAsync(source, path)\n}\n\nfunction loadWebAssembly(\n  chunkPath: ChunkPath,\n  _edgeModule: () => WebAssembly.Module,\n  imports: WebAssembly.Imports\n) {\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n\n  return instantiateWebAssemblyFromPath(resolved, imports)\n}\n\nfunction loadWebAssemblyModule(\n  chunkPath: ChunkPath,\n  _edgeModule: () => WebAssembly.Module\n) {\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n\n  return compileWebAssemblyFromPath(resolved)\n}\n\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\n  throw new Error('Worker blobs are not implemented yet for Node.js')\n}\n\nfunction instantiateModule(id: ModuleId, source: SourceInfo): Module {\n  const moduleFactory = moduleFactories[id]\n  if (typeof moduleFactory !== 'function') {\n    // This can happen if modules incorrectly handle HMR disposes/updates,\n    // e.g. when they keep a `setTimeout` around which still executes old code\n    // and contains e.g. a `require(\"something\")` call.\n    let instantiationReason\n    switch (source.type) {\n      case SourceType.Runtime:\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`\n        break\n      case SourceType.Parent:\n        instantiationReason = `because it was required from module ${source.parentId}`\n        break\n      default:\n        invariant(source, (source) => `Unknown source type: ${source?.type}`)\n    }\n    throw new Error(\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\n    )\n  }\n\n  let parents: ModuleId[]\n  switch (source.type) {\n    case SourceType.Runtime:\n      parents = []\n      break\n    case SourceType.Parent:\n      // No need to add this module as a child of the parent module here, this\n      // has already been taken care of in `getOrInstantiateModuleFromParent`.\n      parents = [source.parentId]\n      break\n    default:\n      invariant(source, (source) => `Unknown source type: ${source?.type}`)\n  }\n\n  const module: Module = {\n    exports: {},\n    error: undefined,\n    loaded: false,\n    id,\n    namespaceObject: undefined,\n  }\n  moduleCache[id] = module\n\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n  try {\n    const r = commonJsRequire.bind(null, module)\n    moduleFactory.call(module.exports, {\n      a: asyncModule.bind(null, module),\n      e: module.exports,\n      r,\n      t: runtimeRequire,\n      x: externalRequire,\n      y: externalImport,\n      f: moduleContext,\n      i: esmImport.bind(null, module),\n      s: esmExport.bind(null, module, module.exports),\n      j: dynamicExport.bind(null, module, module.exports),\n      v: exportValue.bind(null, module),\n      n: exportNamespace.bind(null, module),\n      m: module,\n      c: moduleCache,\n      M: moduleFactories,\n      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\n      L: loadChunkAsyncByUrl.bind(null, {\n        type: SourceType.Parent,\n        parentId: id,\n      }),\n      w: loadWebAssembly,\n      u: loadWebAssemblyModule,\n      P: resolveAbsolutePath,\n      U: relativeURL,\n      R: createResolvePathFromModule(r),\n      b: getWorkerBlobURL,\n      z: requireStub,\n    })\n  } catch (error) {\n    module.error = error as any\n    throw error\n  }\n\n  module.loaded = true\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n    interopEsm(module.exports, module.namespaceObject)\n  }\n\n  return module\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it if it is not cached.\n */\n// @ts-ignore\nfunction getOrInstantiateModuleFromParent(\n  id: ModuleId,\n  sourceModule: Module\n): Module {\n  const module = moduleCache[id]\n\n  if (module) {\n    return module\n  }\n\n  return instantiateModule(id, {\n    type: SourceType.Parent,\n    parentId: sourceModule.id,\n  })\n}\n\n/**\n * Instantiates a runtime module.\n */\nfunction instantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\n}\n\n/**\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\n */\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\nfunction getOrInstantiateRuntimeModule(\n  moduleId: ModuleId,\n  chunkPath: ChunkPath\n): Module {\n  const module = moduleCache[moduleId]\n  if (module) {\n    if (module.error) {\n      throw module.error\n    }\n    return module\n  }\n\n  return instantiateRuntimeModule(moduleId, chunkPath)\n}\n\nconst regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/\n/**\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n */\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n  return regexJsUrl.test(chunkUrlOrPath)\n}\n\nmodule.exports = {\n  getOrInstantiateRuntimeModule,\n  loadChunk,\n}\n"],"names":[],"mappings":"AAAA,oDAAoD,GAEpD,mDAAmD;AACnD,+DAA+D;AAC/D,+DAA+D;AAC/D,0DAA0D;AAE1D,IAAA,AAAK,oCAAA;AACH;;;GAGC;AAED;;GAEC;OARE;EAAA;AAsBL,QAAQ,GAAG,CAAC,SAAS,GAAG;AAExB,SAAS,oBAAoB,MAAkB;AAC7C,OAAQ,OAAO,IAAI;AACjB;AACE,OAAO,CAAC,kBAAkB,EAAE,OAAO,SAAS,EAAE;AAChD;AACE,OAAO,CAAC,cAAc,EAAE,OAAO,QAAQ,EAAE;AAC3C;AACE,UAAU,QAAQ,CAAC,SAAW,CAAC,qBAAqB,EAAE,QAAQ,MAAM;AACxE;AACF;AAoBA,MAAM,MAAM,QAAQ;AACpB,MAAM,KAAK,QAAQ;AAEnB,MAAM,kBAAmC,OAAO,MAAM,CAAC;AACvD,MAAM,cAAmC,OAAO,MAAM,CAAC;AAEvD;;CAEC,GACD,SAAS,4BACP,QAAuC;AAEvC,OAAO,SAAS,sBAAsB,QAAgB;AACpD,MAAM,WAAW,SAAS;AAC1B,MAAM,eAAe,UAAU,WAAW;AAC1C,IAAI,OAAO,iBAAiB,UAAU;AACpC,OAAO;AACT;AAEA,MAAM,sBAAsB,aAAa,KAAK,CAAC,aAAa,MAAM;AAClE,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;AAE5C,OAAO,IAAI,aAAa,CAAC,UAAU,IAAI;AACzC;AACF;AAEA,SAAS,UAAU,SAAoB,EAAE,MAAmB;AAC1D,IAAI,OAAO,cAAc,UAAU;AACjC,OAAO,cAAc,WAAW;AAClC,OAAO;AACL,OAAO,cAAc,UAAU,IAAI,EAAE;AACvC;AACF;AAEA,MAAM,eAAe,IAAI;AAEzB,SAAS,cAAc,SAAoB,EAAE,MAAmB;AAC9D,IAAI,CAAC,KAAK,YAAY;AACpB,gDAAgD;AAChD,0DAA0D;AAC1D;AACF;AAEA,IAAI,aAAa,GAAG,CAAC,YAAY;AAC/B;AACF;AAEA,IAAI;AACF,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;AAC5C,MAAM,eAAgC,QAAQ;AAE9C,KAAK,MAAM,CAAC,UAAU,cAAc,IAAI,OAAO,OAAO,CAAC,cAAe;AACpE,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;AAC9B,eAAe,CAAC,SAAS,GAAG;AAC9B;AACF;AACA,aAAa,GAAG,CAAC;AACnB,EAAE,OAAO,GAAG;AACV,IAAI,eAAe,CAAC,qBAAqB,EAAE,WAAW;AAEtD,IAAI,QAAQ;AACV,gBAAgB,CAAC,MAAM,EAAE,oBAAoB,SAAS;AACxD;AAEA,MAAM,IAAI,MAAM,cAAc;AAC5B,OAAO;AACT;AACF;AACF;AAEA,eAAe,eACb,MAAkB,EAClB,SAAoB;AAEpB,MAAM,YAAY,OAAO,cAAc,WAAW,YAAY,UAAU,IAAI;AAC5E,IAAI,CAAC,KAAK,YAAY;AACpB,gDAAgD;AAChD,0DAA0D;AAC1D;AACF;AAEA,IAAI,aAAa,GAAG,CAAC,YAAY;AAC/B;AACF;AAEA,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;AAE5C,IAAI;AACF,MAAM,WAAW,MAAM,GAAG,QAAQ,CAAC,UAAU;AAE7C,MAAM,eAAe,CAAC;AACpB,IAAI,aAAa,QAAQ,OAAO,CAAC,IAAI;AAAE,OAAO;AAAC,KAAK,OAAO,CAAC;CAAU;AAAC;AACvE,OAAO,QAAQ;AACjB;AACA,MAAM,UAAS;AACb,SAAS,CAAC;AACZ;AAGC,CAAC,GAAG,IAAI,EACP,iEACE,WACA,SACA,qBACA,IAAI,aAAa,CAAC,WACpB,SAAQ,QAAO,OAAO,EAAE,cAAc,KAAK,OAAO,CAAC,WAAW;AAEhE,MAAM,eAAgC,QAAO,OAAO;AACpD,KAAK,MAAM,CAAC,UAAU,cAAc,IAAI,OAAO,OAAO,CAAC,cAAe;AACpE,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE;AAC9B,eAAe,CAAC,SAAS,GAAG;AAC9B;AACF;AACA,aAAa,GAAG,CAAC;AACnB,EAAE,OAAO,GAAG;AACV,IAAI,eAAe,CAAC,qBAAqB,EAAE,WAAW;AAEtD,IAAI,QAAQ;AACV,gBAAgB,CAAC,MAAM,EAAE,oBAAoB,SAAS;AACxD;AAEA,MAAM,IAAI,MAAM,cAAc;AAC5B,OAAO;AACT;AACF;AACF;AAEA,eAAe,oBAAoB,MAAkB,EAAE,QAAgB;AACrE,MAAM,QAAO,IAAI,aAAa,CAAC,IAAI,IAAI,UAAU;AACjD,OAAO,eAAe,QAAQ;AAChC;AAEA,SAAS,gBACP,SAAoB,EACpB,WAAqC,EACrC,OAA4B;AAE5B,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;AAE5C,OAAO,+BAA+B,UAAU;AAClD;AAEA,SAAS,sBACP,SAAoB,EACpB,WAAqC;AAErC,MAAM,WAAW,KAAK,OAAO,CAAC,cAAc;AAE5C,OAAO,2BAA2B;AACpC;AAEA,SAAS,iBAAiB,OAAoB;AAC5C,MAAM,IAAI,MAAM;AAClB;AAEA,SAAS,kBAAkB,EAAY,EAAE,MAAkB;AACzD,MAAM,gBAAgB,eAAe,CAAC,GAAG;AACzC,IAAI,OAAO,kBAAkB,YAAY;AACvC,sEAAsE;AACtE,0EAA0E;AAC1E,mDAAmD;AACnD,IAAI;AACJ,OAAQ,OAAO,IAAI;AACjB;AACE,sBAAsB,CAAC,4BAA4B,EAAE,OAAO,SAAS,EAAE;AACvE;AACF;AACE,sBAAsB,CAAC,oCAAoC,EAAE,OAAO,QAAQ,EAAE;AAC9E;AACF;AACE,UAAU,QAAQ,CAAC,SAAW,CAAC,qBAAqB,EAAE,QAAQ,MAAM;AACxE;AACA,MAAM,IAAI,MACR,CAAC,OAAO,EAAE,GAAG,kBAAkB,EAAE,oBAAoB,uFAAuF,CAAC;AAEjJ;AAEA,IAAI;AACJ,OAAQ,OAAO,IAAI;AACjB;AACE,UAAU,EAAE;AACZ;AACF;AACE,wEAAwE;AACxE,wEAAwE;AACxE,UAAU;AAAC,OAAO,QAAQ;CAAC;AAC3B;AACF;AACE,UAAU,QAAQ,CAAC,SAAW,CAAC,qBAAqB,EAAE,QAAQ,MAAM;AACxE;AAEA,MAAM,UAAiB;AACrB,SAAS,CAAC;AACV,OAAO;AACP,QAAQ;AACR;AACA,iBAAiB;AACnB;AACA,WAAW,CAAC,GAAG,GAAG;AAElB,4EAA4E;AAC5E,IAAI;AACF,MAAM,IAAI,gBAAgB,IAAI,CAAC,MAAM;AACrC,cAAc,IAAI,CAAC,QAAO,OAAO,EAAE;AACjC,GAAG,YAAY,IAAI,CAAC,MAAM;AAC1B,GAAG,QAAO,OAAO;AACjB;AACA,GAAG;AACH,GAAG;AACH,GAAG;AACH,GAAG;AACH,GAAG,UAAU,IAAI,CAAC,MAAM;AACxB,GAAG,UAAU,IAAI,CAAC,MAAM,SAAQ,QAAO,OAAO;AAC9C,GAAG,cAAc,IAAI,CAAC,MAAM,SAAQ,QAAO,OAAO;AAClD,GAAG,YAAY,IAAI,CAAC,MAAM;AAC1B,GAAG,gBAAgB,IAAI,CAAC,MAAM;AAC9B,GAAG;AACH,GAAG;AACH,GAAG;AACH,GAAG,eAAe,IAAI,CAAC,MAAM;AAAE,IAAI;AAAqB,UAAU;AAAG;AACrE,GAAG,oBAAoB,IAAI,CAAC,MAAM;AAChC,IAAI;AACJ,UAAU;AACZ;AACA,GAAG;AACH,GAAG;AACH,GAAG;AACH,GAAG;AACH,GAAG,4BAA4B;AAC/B,GAAG;AACH,GAAG;AACL;AACF,EAAE,OAAO,OAAO;AACd,QAAO,KAAK,GAAG;AACf,MAAM;AACR;AAEA,QAAO,MAAM,GAAG;AAChB,IAAI,QAAO,eAAe,IAAI,QAAO,OAAO,KAAK,QAAO,eAAe,EAAE;AACvE,yDAAyD;AACzD,WAAW,QAAO,OAAO,EAAE,QAAO,eAAe;AACnD;AAEA,OAAO;AACT;AAEA;;CAEC,GACD,aAAa;AACb,SAAS,iCACP,EAAY,EACZ,YAAoB;AAEpB,MAAM,UAAS,WAAW,CAAC,GAAG;AAE9B,IAAI,SAAQ;AACV,OAAO;AACT;AAEA,OAAO,kBAAkB,IAAI;AAC3B,IAAI;AACJ,UAAU,aAAa,EAAE;AAC3B;AACF;AAEA;;CAEC,GACD,SAAS,yBACP,QAAkB,EAClB,SAAoB;AAEpB,OAAO,kBAAkB,UAAU;AAAE,IAAI;AAAsB;AAAU;AAC3E;AAEA;;CAEC,GACD,oFAAoF;AACpF,SAAS,8BACP,QAAkB,EAClB,SAAoB;AAEpB,MAAM,UAAS,WAAW,CAAC,SAAS;AACpC,IAAI,SAAQ;AACV,IAAI,QAAO,KAAK,EAAE;AAChB,MAAM,QAAO,KAAK;AACpB;AACA,OAAO;AACT;AAEA,OAAO,yBAAyB,UAAU;AAC5C;AAEA,MAAM,aAAa;AACnB;;CAEC,GACD,SAAS,KAAK,cAAoC;AAChD,OAAO,WAAW,IAAI,CAAC;AACzB;AAEA,OAAO,OAAO,GAAG;AACf;AACA;AACF","ignoreList":[0]}}]
}